= BridJ & Callbacks

BridJ has full support for callbacks. You can pass a callback object to a native function allowing the library to call back to Java. You can also receive function pointers from the native code, and call into the library through it.

== The Callback type

A function pointer type is represented by an abstract subclass of http://nativelibs4java.sourceforge.net/bridj/api/stable/org/bridj/Callback.html[org.bridj.Callback] in Java code.
It has a single abstract function that mirrors the signature of the native function:

[source,java]
----
public static abstract class CallbackType extends Callback<CallbackType> {
  public abstract int apply(Pointer<Byte> buffer, int length);
}
----

If you receive a function pointer, it will be a `Pointer<CallbackType>` object; you can access the actual callback with the `Pointer.get()`
function and then call `apply`. To pass a callback to a native function, extend the abstract class, provide an implementation to the `apply` method,
and wrap instances of this callback object in a pointer using `Pointer.pointerTo`.

[source,java]
----
CallbackType actualCallback=new CallbackType() {
  public int apply(Pointer<Byte> buffer, int length) {
    System.out.format("Received %d bytes%n", length);
    return 0;
  }
}
----

NOTE: if the native code stores your callback, you need to make sure that the Java callback object is not garbage collected
while the native code uses it, otherwise your program will crash.
You can use http://nativelibs4java.sourceforge.net/bridj/api/stable/org/bridj/BridJ.html#protectFromGC(T)[BridJ.protectFromGC] and
http://nativelibs4java.sourceforge.net/bridj/api/stable/org/bridj/BridJ.html#unprotectFromGC(T)[BridJ.unprotectFromGC] for this purpose:

[source,java]
----
MyLibrary.registerCallback(Pointer.pointerTo(actualCallback));
BridJ.protectFromGC(actualCallback);

// when it is time to stop the native code from using the callback
MyLibrary.unregisterCallback(Pointer.pointerTo(actualCallback));
BridJ.unprotectFromGC(actualCallback);
----

== Complete example

Native header:

[source,c++]
----
typedef int (*CallbackType)();

void callMe(CallbackType);
CallbackType getNativeCallback();
----

Java bindings (generated by http://jnaerator.googlecode.com/[JNAerator]):

[source,java]
----
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Runtime;

@Library("CallbackTest")
@Runtime(CRuntime.class)
public class CallbackTestLibrary {
  static {
    BridJ.register();
  }
  public static abstract class CallbackType extends Callback<CallbackType > {
    public abstract int apply();
  };
  public static native void callMe(Pointer<CallbackTestLibrary.CallbackType > CallbackType1);
  public static native Pointer<CallbackTestLibrary.CallbackType > getNativeCallback();
}
----

Using the library:

[source,java]
----
import org.bridj.Pointer;

public class Main {

  public static void main(String[] args) throws Exception {
    // call a callback function received from the library
    System.out.println("C callback returned " + CallbackTestLibrary.getNativeCallback().get().apply());
    
    // create a callback function in Java
    CallbackTestLibrary.CallbackType callback = new CallbackTestLibrary.CallbackType() {
      @Override
      public int apply() {
        System.out.println("Java callback called");
        return 175;
      }
    };

    // pass a callback function to the library
    CallbackTestLibrary.callMe(Pointer.pointerTo(callback));
  }
}
----

Implementation of the native library:

[source,c++]
----
#include "CallbackTest.h"
#include "stdio.h"

void callMe(CallbackType c) {
    printf("Java code returned %d\n",c());
    fflush(stdout);
}

int prCb() {
    printf("Native function called\n");
    fflush(stdout);
    return 56;
}

CallbackType getNativeCallback() {
    return &prCb;
}
----

For this example the Java program prints the following:

----
Native function called
C callback returned 56
Java callback called
Java code returned 175
----
